Now generate ci.sh as code above.

Of course. Here is the ci.sh script that mirrors the logic of your .bat file.

This script is designed for Linux and macOS.

Bash

#!/bin/bash

# Exit immediately if a command exits with a non-zero status.
# This ensures the script stops if any step fails (e.g., compilation error).
set -e

# --- 1. Create build directory ---
# The '-p' flag prevents an error if the directory already exists.
echo "Creating build directory..."
mkdir -p build

# --- 2. Navigate into the build directory ---
cd build

# --- 3. Configure the project with CMake ---
echo "Configuring with CMake..."
cmake ..

# --- 4. Build the project ---
echo "Building project..."
cmake --build .

# --- 5. Run tests ---
# The logic in your .bat file runs the same command for both OS conditions,
# so we just need the command itself here.
echo "Running tests..."
ctest --output-on-failure

echo "Script finished successfully!"
Key Differences and Explanations
#!/bin/bash: This is the shebang, which tells the system to execute this script using the Bash interpreter. It's a required first line for shell scripts.

set -e: This is the Bash equivalent of checking %errorlevel% after every command. If any command fails (returns a non-zero exit code), the script will stop immediately. This is crucial for CI scripts.

mkdir -p build: This is a more direct way to achieve if not exist build mkdir build. The -p (--parents) flag creates the directory and won't show an error if it already exists.

No OS Check Needed: Your .bat script runs ctest --output-on-failure in both the if and else blocks. Since the command is identical regardless of the OS, the check is redundant. The ci.sh script simplifies this by just running the command directly.

Using Copilot for YML: In the ci.yml file, use Copilot to generate a workflow with the following requirements:

Trigger: Run the action on a push or pull_request to a branch containing develop or master in its name.

Job: Create a single Job (e.g., cross_build).

Strategy: Use a matrix (strategy: matrix) to run the build on three OSes:

runs-on: ubuntu-latest (Linux)

runs-on: windows-latest (Windows)

runs-on: macos-latest (macOS)

Steps: Each build must include the following steps:

Checkout code (actions/checkout@v4).

Install CMake (if necessary).

Run configuration and build commands (run the script from Stage 3).

Create artifacts.

Deploy.


Of course, here is the complete workflow for GitHub Actions, created according to your requirements.

You need to create a file at the following path in your repository: .github/workflows/ci.yml and paste the code below into it.

The ci.yml File
YAML

# Name of the workflow, which will be displayed in the "Actions" tab on GitHub
name: CI/CD Cross-Platform Build

# --- Trigger: Conditions for starting the workflow ---
# This block defines when the workflow will be automatically triggered.
on:
  # Trigger on a push to branches named 'master' or 'develop'
  push:
    branches: [ master, develop ]
  
  # Trigger on creation or update of a Pull Request targeting 'master' or 'develop'
  pull_request:
    branches: [ master, develop ]

# --- Jobs: Tasks to be executed ---
jobs:
  # The name of the single job, as required
  cross_build:
    
    # --- Strategy & Matrix: Strategy for parallel execution ---
    # This block allows running the same job on different configurations.
    strategy:
      matrix:
        # We define a variable 'os' which will sequentially take each of these values.
        # The 'cross_build' job will run 3 times in parallel, one for each OS.
        os: [ubuntu-latest, windows-latest, macos-latest]

    # Specify on which operating system (runner) to execute the job.
    # ${{ matrix.os }} is a dynamic reference to the value from the list above.
    runs-on: ${{ matrix.os }}

    # --- Steps: Step-by-step instructions ---
    # The steps are executed sequentially for each job in the matrix.
    steps:
      # Step 1: Check out the code from the repository
      # Use the ready-made action 'actions/checkout' version 4.
      - name: Checkout code
        uses: actions/checkout@v4

      # Step 2: Run configuration, build, and tests
      # Here we execute the scripts created in the previous stage.
      # The 'if' condition allows running the correct script for each OS.
      - name: Build and Test
        run: |
          # For Linux and macOS (all non-Windows systems)
          if [ "${{ runner.os }}" != "Windows" ]; then
            chmod +x ci.sh
            ./ci.sh
          # For Windows
          else
            ./ci.bat
          fi
        shell: bash

      # Step 3: Create artifacts
      # This step uploads the build result (the executable file) as an artifact.
      # Artifacts can be downloaded from the workflow run page.
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          # The artifact name will be unique for each OS, e.g., 'hello-windows-latest'
          name: hello-${{ runner.os }}
          # The path to the file that needs to be uploaded.
          # Note: the path may need adjustment depending on your CMake configuration
          # (e.g., 'build/Release/hello.exe' for a release build on Windows).
          path: |
            build/hello
            build/Debug/hello.exe
            build/Release/hello.exe
          if-no-files-found: warn # Don't fail the job if no files are found

      # Step 4: Deploy
      # This is an EXAMPLE step. Real deployment requires configuring secrets and scripts.
      # This step runs ONLY on a push to the 'master' branch.
      - name: Deploy (Placeholder)
        if: github.ref == 'refs/heads/master' && github.event_name == 'push'
        run: |
          echo "Deploying artifact for ${{ runner.os }}..."
          echo "This is a placeholder. Real deployment script goes here."
Explanation of Key Points
on (Trigger): This section precisely matches your requirement: the workflow is activated on a push or pull_request to the master and develop branches.

strategy: matrix: This is the core of the cross-platform build. GitHub Actions will automatically create and run three parallel jobs, substituting ubuntu-latest, windows-latest, and macos-latest into the runs-on field.

Script Execution: The "Build and Test" step uses the ${{ runner.os }} variable to determine the current operating system.

If the OS is not Windows, it makes ci.sh executable (chmod +x) and then runs it.

If the OS is Windows, it runs ci.bat.

shell: bash forces Windows to use Git Bash to execute this step, which simplifies writing a single conditional block.

actions/upload-artifact: This standard action gathers the files specified in path and attaches them to the workflow run's results. This allows you to easily download the compiled applications for each OS.

Deploy (Placeholder): This step is a template. The important part is the condition if: github.ref == 'refs/heads/master' && github.event_name == 'push', which ensures that deployment only happens when changes are merged into the main master branch, not from every pull request or push to develop.




