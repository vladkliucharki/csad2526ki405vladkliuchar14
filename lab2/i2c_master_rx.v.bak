/*
 * Модуль: i2c_master_rx (I2C Master Receiver / Декодер)
 * Мова: Verilog
 * Завдання: 14
 *
 * Призначення: 
 * Реалізує логіку I2C Master для прийому одного байта даних (Read).
 * Генерує тактові імпульси (SCL) та керує потоком даних (SDA).
 */
module i2c_master_rx (
    // --- Системні порти ---
    input wire           clk,        // Системний тактовий сигнал
    input wire           rst_n,      // Асинхронний активний-низький скид

    // --- Порти керування від користувача ---
    input wire           start_rx,   // Імпульс для початку транзакції
    input wire [6:0]     slave_addr, // 7-бітна адреса Slave-пристрою

    // --- Порти стану та даних ---
    output wire          busy,       // '1' - транзакція в процесі
    output wire          ack_error,  // '1' - якщо отримано NACK (помилка)
    output wire [7:0]    data_out,   // 8-бітний байт отриманих даних
    output wire          data_ready  // '1' - імпульс, що data_out валідні

    // --- Порти шини I2C ---
    inout wire           sda,        // Двонаправлена лінія даних I2C
    output wire          scl         // Лінія тактування I2C (генерується майстром)
);

    // =========================================================================
    // --- Параметри дільника тактової частоти ---
    // =========================================================================
    parameter CLK_FREQ = 50_000_000;
    parameter I2C_FREQ = 100_000;
    localparam HALF_PERIOD_COUNT = (CLK_FREQ / (I2C_FREQ * 2)) - 1;

    // =========================================================================
    // --- Внутрішні регістри та сигнали ---
    // =========================================================================
    
    // --- Дільник тактової частоти ---
    reg [$clog2(HALF_PERIOD_COUNT):0] clk_div_cnt;
    reg tick;

    // --- Регістри FSM ---
    reg [4:0] state;
    reg busy_reg;
    reg ack_error_reg;
    reg data_ready_reg;
    
    // --- Регістри керування шиною ---
    reg scl_reg;
    reg sda_o_reg;
    reg sda_en_reg;

    // --- Регістри даних ---
    reg [7:0] shift_reg;   // Зсувний регістр (для адреси + R/W, та прийому даних)
    reg [7:0] data_out_reg;
    reg [2:0] bit_cnt;

    // --- Стани FSM ---
    localparam S_IDLE             = 5'd0;  // Очікування
    localparam S_START_1          = 5'd1;  // Генерація START
    localparam S_START_2          = 5'd2;
    localparam S_TX_ADDR_BIT      = 5'd3;  // Передача біта адреси
    localparam S_TX_ADDR_CLK_HI   = 5'd4;
    localparam S_TX_ADDR_CLK_LO   = 5'd5;
    localparam S_GET_ADDR_ACK_1   = 5'd6;  // Отримання ACK (після адреси)
    localparam S_GET_ADDR_ACK_CLK = 5'd7;
    localparam S_GET_ADDR_ACK_RD  = 5'd8;
    localparam S_GET_ADDR_ACK_LO  = 5'd9;
    localparam S_RX_CLK_HI        = 5'd10; // Прийом біта даних
    localparam S_RX_BIT_READ      = 5'd11;
    localparam S_RX_CLK_LO        = 5'd12;
    localparam S_SEND_NACK_1      = 5'd13; // Посилка NACK (завершення читання)
    localparam S_SEND_NACK_CLK_HI = 5'd14;
    localparam S_SEND_NACK_CLK_LO = 5'd15;
    localparam S_STOP_1           = 5'd16; // Генерація STOP
    localparam S_STOP_CLK_HI      = 5'd17;
    localparam S_STOP_2           = 5'd18;

    // =========================================================================
    // --- Призначення виходів ---
    // =========================================================================
    assign scl = scl_reg;
    assign sda = (sda_en_reg) ? sda_o_reg : 1'bz;
    assign busy = busy_reg;
    assign ack_error = ack_error_reg;
    assign data_out = data_out_reg;
    assign data_ready = data_ready_reg;

    // =========================================================================
    // --- Логіка дільника тактової частоти ---
    // =========================================================================
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            clk_div_cnt <= 0;
            tick <= 1'b0;
        end else begin
            if (clk_div_cnt == HALF_PERIOD_COUNT) begin
                clk_div_cnt <= 0;
                tick <= 1'b1;
            end else begin
                clk_div_cnt <= clk_div_cnt + 1;
                tick <= 1'b0;
            end
        end
    end

    // =========================================================================
    // --- Логіка FSM (Машина Станів) ---
    // =========================================================================
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            // Скидання в початковий стан
            state <= S_IDLE;
            scl_reg <= 1'b1; sda_o_reg <= 1'b1; sda_en_reg <= 1'b1;
            busy_reg <= 1'b0; ack_error_reg <= 1'b0; data_ready_reg <= 1'b0;
            data_out_reg <= 0; bit_cnt <= 0; shift_reg <= 0;
            
        end else if (tick) begin 
            
            // data_ready - це імпульс, скидаємо його за замовчуванням
            data_ready_reg <= 1'b0;
            
            case (state)
                
                // --- Стан Очікування ---
                S_IDLE: begin
                    busy_reg <= 1'b0;
                    ack_error_reg <= 1'b0;
                    scl_reg <= 1'b1; sda_o_reg <= 1'b1; sda_en_reg <= 1'b1; 
                    
                    if (start_rx) begin
                        busy_reg <= 1'b1;
                        state <= S_START_1;
                    end
                end

                // --- Умова START ---
                S_START_1: begin
                    sda_o_reg <= 1'b0;
                    state <= S_START_2;
                end
                
                S_START_2: begin
                    scl_reg <= 1'b0;
                    // Завантажуємо адресу і біт R/W=1 (Read)
                    shift_reg <= {slave_addr, 1'b1}; 
                    bit_cnt <= 3'd7; 
                    state <= S_TX_ADDR_BIT;
                end

                // --- Передача Біта (Адреси) ---
                S_TX_ADDR_BIT: begin
                    sda_o_reg <= shift_reg[7];
                    state <= S_TX_ADDR_CLK_HI;
                end
                
                S_TX_ADDR_CLK_HI: begin
                    scl_reg <= 1'b1;
                    state <= S_TX_ADDR_CLK_LO;
                end
                
                S_TX_ADDR_CLK_LO: begin
                    scl_reg <= 1'b0;
                    if (bit_cnt == 0) begin
                        state <= S_GET_ADDR_ACK_1;
                    end else begin
                        shift_reg <= shift_reg << 1;
                        bit_cnt <= bit_cnt - 1;
                        state <= S_TX_ADDR_BIT;
                    end
                end

                // --- Отримання ACK/NACK (після Адреси) ---
                S_GET_ADDR_ACK_1: begin
                    sda_en_reg <= 1'b0; // "Відпускаємо" SDA
                    state <= S_GET_ADDR_ACK_CLK;
                end
                
                S_GET_ADDR_ACK_CLK: begin
                    scl_reg <= 1'b1;
                    state <= S_GET_ADDR_ACK_RD;
                end
                
                S_GET_ADDR_ACK_RD: begin
                    if (sda == 1'b1) begin // '1' == NACK
                        ack_error_reg <= 1'b1;
                    end
                    state <= S_GET_ADDR_ACK_LO;
                end

                S_GET_ADDR_ACK_LO: begin
                    scl_reg <= 1'b0;
                    if (ack_error_reg) begin
                        sda_en_reg <= 1'b1; // Повертаємо контроль
                        state <= S_STOP_1;  // Помилка, зупинка
                    end else begin
                        // Отримали ACK, готуємось до прийому даних
                        bit_cnt <= 3'd7; 
                        shift_reg <= 0;  // Очищуємо зсувний регістр
                        state <= S_RX_CLK_HI;
                        // sda_en_reg залишається '0' (Hi-Z), бо ми слухаємо
                    end
                end

                // --- Прийом Байта Даних ---
                S_RX_CLK_HI: begin
                    scl_reg <= 1'b1; // SCL=1
                    state <= S_RX_BIT_READ;
                end

                S_RX_BIT_READ: begin
                    // Читаємо біт з SDA (поки SCL=1)
                    shift_reg <= {shift_reg[6:0], sda}; // Зсуваємо і записуємо
                    state <= S_RX_CLK_LO;
                end
                
                S_RX_CLK_LO: begin
                    scl_reg <= 1'b0; // SCL=0
                    if (bit_cnt == 0) begin
                        // Отримали всі 8 біт
                        data_out_reg <= shift_reg; // Зберігаємо результат
                        data_ready_reg <= 1'b1;    // Сигналізуємо про готовність
                        state <= S_SEND_NACK_1;    // Посилаємо NACK (кінець прийому)
                    end else begin
                        bit_cnt <= bit_cnt - 1;
                        state <= S_RX_CLK_HI; // Наступний біт
                    end
                end

                // --- Посилка NACK (завершення читання) ---
                S_SEND_NACK_1: begin
                    // Ми (Майстер) посилаємо NACK, щоб сказати Slave "досить"
                    sda_en_reg <= 1'b1;    // Беремо контроль над SDA
                    sda_o_reg <= 1'b1;     // Виставляємо '1' (NACK)
                    state <= S_SEND_NACK_CLK_HI;
                end
                
                S_SEND_NACK_CLK_HI: begin
                    scl_reg <= 1'b1;
                    state <= S_SEND_NACK_CLK_LO;
                end
                
                S_SEND_NACK_CLK_LO: begin
                    scl_reg <= 1'b0;
                    state <= S_STOP_1; // Переходимо до STOP
                end

                // --- Умова STOP ---
                S_STOP_1: begin
                    sda_en_reg <= 1'b1;
                    sda_o_reg <= 1'b0;
                    state <= S_STOP_CLK_HI;
                end

                S_STOP_CLK_HI: begin
                    scl_reg <= 1'b1;
                    state <= S_STOP_2;
                end
                
                S_STOP_2: begin
                    sda_o_reg <= 1'b1;
                    state <= S_IDLE;
                end
                
                default: begin
                    state <= S_IDLE;
                end
                
            endcase
        end
    end

endmodule